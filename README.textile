h1. "Pure Data":puredata.info/ testing external

h3. Async Functional testing for *Pure Data* using *Lua* scripting.

p. _PdTest_ is intended at developers of Pure Data externals that needs functional testing for their project.  Functional tests are organised as test suites, grouping test cases that coordinates the many individual tests.  The pdtest external features mandatory inlet type creation arguments, adding test inlets for receiving results of the specifed types, while the active left inlet is used for loading test suites, starting, stopping and resetting the test loop.  Test are built using standard Lua scripts, with provided helper functions for declaring the test structure.  Refer to "Lua documentation":http://www.lua.org/docs.html to learn more about test scripts syntax.

!https://github.com/lp/pdtest/raw/master/img/pdtest-help.png!

h2. Test Suite Syntax:

h4. Building a test suite is _easy_ when you know its basics:

h3. The pdtest namespace

bc. pdtest      -- the pdtest namespace object
pdtest.suite("suite name")                              -- suite creation function
pdtest.post("string to post")                           -- post to pd console
pdtest.error("string to signal")                        -- sends error to pd console

h3. The pdtest.out namespace -> tested messages

bc. pdtest.out.list({"YOUR","MESSAGE","LIST"})          -- sends lua table as test message list through outlet
pdtest.out.symbol("STRING")                             -- sends lua string as test message symbol through outlet
pdtest.out.number(3.1416)                               -- sends lua number as test message float through outlet
pdtest.out.bang()                                       -- sends bang as test message through outlet

h3. The pdtest.raw namespace -> untested messages

bc. pdtest.raw.list({"YOUR","MESSAGE","LIST"})          -- sends lua table as raw message list through outlet
pdtest.raw.symbol("STRING")                             -- sends lua string as raw message symbol through outlet
pdtest.raw.number(3.1416)                               -- sends lua number as raw message float through outlet
pdtest.raw.bang()                                       -- sends bang as raw message through outlet

h3. Suites functions

bc. mysuite = pdtest.suite("my test suite")
mysuite.setup(function()                                -- set a setup function to be called
    pdtest.raw.list({"SOME","SETUP","MESSAGE"})      -- before all of this suite tests
end)
mysuite.teardown(function()                             -- set a cleanup function to be called
    pdtest.raw.list({"SOME","CLEANUP","MESSAGE"})    -- after all of this suite tests
end)
mysuite.case("my test case")                            -- define a new test case

h3. Cases functions

bc. mycase = mysuite.case("my test case")
mycase.setup(function()                                 -- set a setup function to be called
    pdtest.raw.list({"SOME","SETUP","MESSAGE"})      -- before all of this case tests
end)
mycase.teardown(function()                              -- set a cleanup function to be called
    pdtest.raw.list({"SOME","CLEANUP","MESSAGE"})    -- after all of this case tests
end)
mycase.test({"MY","TEST","MESSAGE"})                    -- lua table as pd list message to outlet
mycase.test("MESSAGE")                                  -- lua string as pd symbol message to outlet
mycase.test(3.1416)                                     -- lua number as pd float message to outlet
mycase.test(function()                                  -- long test form, function body can contain only one
    pdtest.out.list({"MY","TEST","MESSAGE"})            -- pdtest.out.<type>() call, but unlimited pdtest.raw.<type>().
end)

h3. Tests functions

bc. mycase.test({"MY","TEST","MESSAGE"}                     -- tests are made by calling condition methods
    ).should:equal(                                     -- like equal() from the .should namespace
        {"TEST","DESIRED","OUTPUT","MESSAGE"})          -- notice the colon for calling condition methods
mycase.test({"MY","TEST","MESSAGE"}                     -- tests can also be reversed by calling them
    ).should.nt:equal(                                  -- from the .should.nt namespace
        {"TEST","NOT","DESIRED","OUTPUT","MESSAGE"})

h3. Conditions methods

bc. .should:equal(                                          -- equal method test for message content equality
    {"TEST","DESIRED","OUTPUT","MESSAGE"})
.should.nt:equal(                                       -- not equal method
    {"TEST","DESIRED","OUTPUT","MESSAGE"})
--
.should:match("%d+%s%a+")                               -- match method matches individual result atoms
                                                        -- against string pattern according to "lua's matching":http://www.lua.org/pil/20.2.html
                                                        -- mechanism.
.should.nt:match("%d+%s%a+")                            -- not match method
--
.should:be_true(function(result)                        -- be_true method test if provided function returns
    if result[1] == "OK" then                           -- true or false
        return true
    else
        return false
    end
end)
.should.nt:be_true(function(result)                     -- not be_true (be_false...)
    if result[1] == "ERROR" then
        return true
    else
        return false
    end
end)

h3. Example Tests Suite

!https://github.com/lp/pdtest/raw/master/img/pdtest_example.png!

h5. examplesuite.lua

bc. mysuite = pdtest.suite("TestSuite") -- initializing a new test suite named "TestSuite"

bc. mysuite.setup(function()                -- called before every test in the suite
  pdtest.raw.list({"command","flushdb"})
end)

bc. mysuite.teardown(function()             -- called after every test in the suite
  pdtest.raw.list({"command","flushdb"})
end)

bc. mysuite.case("Server Info"              -- new test case named "Server Info"
  ).test({"command", "INFO"}            -- will output message "list command INFO"
    ).should:match("^redis_version")    -- test will pass if result received on right 
                                        -- inlet starts with the string "redis_version"

bc. mysuite.case("Reality Check"            -- second test case named "Reality Check"
  ).test({"command", "dummy"}           -- will output message "list command dummy"
    ).should:match("ERR"                -- test will pass if result received on right
  ).test({"command", "dbsize"}          -- inlet match the string "ERR"
    ).should.nt:match("ERR")            -- second test will pass if result doesn't match "ERR"

bc. mycase = mysuite.case("Basic tests")    -- new test case named "Basic tests"

bc. mycase.setup(                           -- called before every test in the case
  function() pdtest.raw.list({"command","SET","FOO","BAR"})
end)

bc. mycase.test({"command", "GET", "FOO"}   -- test will pass if result equals "BAR"
  ).should:equal("BAR")

bc. mycase.test(function()                  -- here a test function is passed instead
        pdtest.raw.list({"command","DEL","FOO"})
        pdtest.out.list({"command","EXISTS","FOO"})
    end).should:equal(0)

bc. mycase.test(
  {"command","SETNX","FOO","BAT"}
  ).should:be_true(function(result)     -- test method '.should:be_true' takes a function
    if result == 1 then                 -- for which it provides a 'result' argument
      return true                       -- the function must return true or false
    else
      return false
    end
  end)

h5. pd console

bc. pdtest: loading testfile examplesuite.lua
pdtest: TestSuite -> Server Info < command, INFO > 
pdtest: -> OK
pdtest: TestSuite -> Reality Check < command, dummy > 
pdtest: -> OK
pdtest: TestSuite -> Reality Check < command, dbsize > 
pdtest: -> OK
pdtest: TestSuite -> Basic tests < command, GET, FOO > 
pdtest: -> OK
pdtest: TestSuite -> Basic tests < function > 
pdtest: -> OK
pdtest: TestSuite -> Basic tests < command, SETNX, FOO, BAT > 
pdtest: x> FAILED |> 0 is not true function
pdtest: !!! Test Completed !!!
pdtest: 1 Suites | 3 Cases | 6 Tests
pdtest: 5 tests passed
pdtest: 1 tests failed


